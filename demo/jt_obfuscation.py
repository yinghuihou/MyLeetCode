#!/usr/bin/python3# -*- coding: utf-8 -*-# @Time    : 2020/2/6 3:47 下午# @File    : jt_obfuscation.py# @Software: PyCharmimport argparseimport ioimport osimport randomimport shutilimport stringimport sysimport timeimport yaml# 资源名称混淆白名单，加入后可以避免被混淆white_list = ["toast_custom.xml"]# 判断全匹配规则，避免出现相同前缀的长短名称混淆出错# 当被匹配的关键字后一位只有在此list内，才能确保是完全匹配，在关键字不是处于行尾的情况下rex_list = [" ", ",", ")"]################# common ###############def random_str(length: int):    return ''.join(random.sample(string.ascii_letters, length))def enumerate_file_in_path(folder_path: str):    list_dirs = os.walk(folder_path)    for root, dirs, files in list_dirs:        for d in dirs:            enumerate_file_in_path(os.path.join(root, d))        for f in files:            yield os.path.join(root, f)################# 产生android端proguard所用混淆字典 ###############def gen_proguard_dict(cur_path: str):    file = open(os.path.join(cur_path, 'jt_obfuscation_proguard_dict.txt'), 'w')    file.write("#proguard dictionary\n")    for i in range(1, 50):        file.write(random_str(5) + "\n")    file.close()################## 混淆dart端资源部分 ############################FLUTTER_NEW_ASSETS: list = []def get_yaml_data(yaml_file):    with open(yaml_file, 'r', encoding="utf-8") as file:        file_data = file.read()        data = yaml.load(file_data)    return datadef gen_new_resource_name(pubspec: dict) -> dict:    assets: list = pubspec['flutter']['assets']    new_assets: list = []    for asset in assets:        base_name: str = os.path.splitext(os.path.basename(asset))[0]        new_base_name = random_str(len(base_name))        new_assets.append(asset.replace(base_name, new_base_name))        FLUTTER_NEW_ASSETS.append({'old': base_name,                                   'new': new_base_name})    pubspec['flutter']['assets'] = new_assets    return pubspecdef save_new_pubspec(data: dict, path: str):    with open(path, 'w') as f:        f.truncate()        yaml.dump(data, f)def replace_resource_in_dart(dir_path: str):    for file_path in enumerate_file_in_path(dir_path):        if file_path.endswith('.dart'):            with open(file_path, 'r+', encoding='utf-8') as f:                has_edited: bool = False                lines = f.readlines()                for i, line in enumerate(lines):                    for resource_info in FLUTTER_NEW_ASSETS:                        base_name: str = resource_info['old']                        new_base_name: str = resource_info['new']                        filter_style_1: str = f'"{base_name}"'                        new_filter_style_1: str = f'"{new_base_name}"'                        filter_style_2: str = f"'{base_name}'"                        new_filter_style_2: str = f"'{new_base_name}'"                        if filter_style_1 in line:                            new_line: str = line.replace(filter_style_1, new_filter_style_1)                            line = new_line                            lines[i] = new_line                            has_edited = True                        elif filter_style_2 in line:                            new_line: str = line.replace(filter_style_2, new_filter_style_2)                            line = new_line                            lines[i] = new_line                            has_edited = True                if has_edited:                    f.seek(0)                    f.truncate()                    f.writelines(lines)        elif 'assets/' in file_path:            for resource_info in FLUTTER_NEW_ASSETS:                if f"/{resource_info['old']}." in file_path:                    new_file_path = file_path.replace(f"/{resource_info['old']}.", f"/{resource_info['new']}.")                    os.rename(file_path, new_file_path)################## 混淆android端资源部分 ############################# 包括对图片资源id修改，layout文件修改，string、color、dimen等一键改名等# 新名称是10-30位的随机字符组成，不同分辨率下的图片会用相同名称def find_all_file_in_path(folder_path):    all_path = []    all_name = []    all_file_list = os.listdir(folder_path)    for file in all_file_list:        file_path = os.path.join(folder_path, file)        if os.path.isdir(file_path):            path, name = find_all_file_in_path(file_path)            all_path.extend(path)            all_name.extend(name)        elif os.path.isfile(file_path):            all_path.append(file_path)            all_name.append(file)    return all_path, all_namedef get_new_random_name():    new_name = random.sample(string.ascii_lowercase, 1)    new_name.extend(random.sample(string.ascii_lowercase + "_", random.randint(10, 26)))    new_name.extend(random.sample(string.ascii_lowercase, 1))    return ''.join(new_name)def replace_resource_in_android(dir_path):    name_map = {}    all_file_path, all_file_name = find_all_file_in_path(dir_path)    for file_path, file_name in zip(all_file_path, all_file_name):        # 如果当前文件在白名单中，则跳过混淆        if file_name in white_list:            continue        if file_path.endswith('.png') or file_path.endswith('.webp') or file_path.endswith(                '.jpg') or (file_path.endswith('.xml') and 'drawable' in file_path):            old_name = file_name.split('.')[0]            if old_name in name_map.keys():                new_name = name_map.get(old_name)            else:                new_name = get_new_random_name()                name_map[old_name] = new_name            new_file_path = file_path.replace(old_name, new_name)            os.rename(file_path, new_file_path)            if 'drawable' in file_path:                replace_pic_in_project(dir_path, old_name, new_name, True)            elif 'mipmap' in file_path:                replace_pic_in_project(dir_path, old_name, new_name, False)        elif file_path.endswith('.xml') and 'layout' in file_path:            old_name = file_name.split('.')[0]            new_name = get_new_random_name()            new_file_path = file_path.replace(old_name, new_name)            os.rename(file_path, new_file_path)            replace_layout_in_project(dir_path, old_name, new_name)        elif file_path.endswith('values/strings.xml') or file_path.endswith('values/dimens.xml') or file_path.endswith(                'values/colors.xml'):            # 对字符串,颜色，距离等资源id的解析替换            replace_ids_in_project(all_file_path, file_path)# 替换strings.xml,dimens.xml,colors.xml中的各个资源id名称def replace_ids_in_project(all_file_path, file_path):    with open(file_path, 'r+', encoding='utf-8') as f:        has_edited: bool = False        lines = f.readlines()        for i, line in enumerate(lines):            if "string name=" in line:                old_name = line.split('"')[1]                new_name = get_new_random_name()                new_line: str = line.replace(old_name, new_name)                lines[i] = new_line                has_edited = True                for fp in all_file_path:                    # 对以下文件直接忽略，无需替换                    if fp.endswith('values/strings.xml') or fp.endswith('values/colors.xml') or fp.endswith(                            'values/dimens.xml'):                        pass                    elif fp.endswith('.java') or fp.endswith('.kt'):                        search_and_replace(fp, "R.string." + old_name, "R.string." + new_name)                    elif fp.endswith('.xml'):                        search_and_replace(fp, "@string/" + old_name, "@string/" + new_name)            elif "dimen name=" in line:                old_name = line.split('"')[1]                new_name = get_new_random_name()                new_line: str = line.replace(old_name, new_name)                lines[i] = new_line                has_edited = True                for fp in all_file_path:                    # 对以下文件直接忽略，无需替换                    if fp.endswith('values/strings.xml') or fp.endswith('values/colors.xml') or fp.endswith(                            'values/dimens.xml'):                        pass                    elif fp.endswith('.java') or fp.endswith('.kt'):                        search_and_replace(fp, "R.dimen." + old_name, "R.dimen." + new_name)                    elif fp.endswith('.xml'):                        search_and_replace(fp, "@dimen/" + old_name, "@dimen/" + new_name)            elif "color name=" in line:                old_name = line.split('"')[1]                new_name = get_new_random_name()                new_line: str = line.replace(old_name, new_name)                lines[i] = new_line                has_edited = True                for fp in all_file_path:                    # 对以下文件直接忽略，无需替换                    if fp.endswith('values/strings.xml') or fp.endswith('values/colors.xml') or fp.endswith(                            'values/dimens.xml'):                        pass                    elif fp.endswith('.java') or fp.endswith('.kt'):                        search_and_replace(fp, "R.color." + old_name, "R.color." + new_name)                    elif fp.endswith('.xml'):                        search_and_replace(fp, "@color/" + old_name, "@color/" + new_name)        if has_edited:            f.seek(0)            f.truncate()            f.writelines(lines)# 替换layout资源名称def replace_layout_in_project(dir_path, old_name, new_name):    all_file_path, all_file_name = find_all_file_in_path(dir_path)    time.sleep(0.5)    for fp in all_file_path:        if fp.endswith('.java') or fp.endswith('.kt'):            # 此处是替换Java文件或kt文件代码中引用的图片            search_and_replace(fp, "R.layout." + old_name, "R.layout." + new_name)        elif fp.endswith('.xml'):            search_and_replace(fp, "@layout/" + old_name, "@layout/" + new_name)# 分类型去替换图片资源，需要有不同的前缀def replace_pic_in_project(dir_path, old_name, new_name, is_drawable):    all_file_path, all_file_name = find_all_file_in_path(dir_path)    time.sleep(0.5)    for fp in all_file_path:        if is_drawable:            if fp.endswith('.java') or fp.endswith('.kt'):                # 此处是替换Java文件或kt文件代码中引用的图片                search_and_replace(fp, 'R.drawable.' + old_name, 'R.drawable.' + new_name)            elif fp.endswith('.xml'):                search_and_replace(fp, '@drawable/' + old_name, '@drawable/' + new_name)        else:            if fp.endswith('.java') or fp.endswith('.kt'):                # 此处是替换Java文件或kt文件代码中引用的图片                search_and_replace(fp, "R.mipmap." + old_name, "R.mipmap." + new_name)            elif fp.endswith('.xml'):                search_and_replace(fp, "@mipmap/" + old_name, "@mipmap/" + new_name)# 真正搜索替换资源名称的操作，包括图片id，layout和字符串等def search_and_replace(fp, old_name, new_name):    with open(fp, 'r+', encoding='utf-8') as f:        has_edited: bool = False        lines = f.readlines()        for i, line in enumerate(lines):            if is_in_line(old_name, line):                new_line: str = line.replace(old_name, new_name)                lines[i] = new_line                has_edited = True        if has_edited:            f.seek(0)            f.truncate()            f.writelines(lines)def is_in_line(old_name: str, line: str):    if line.endswith(old_name):        return True    else:        return old_name in line and line[line.index(old_name) + len(old_name)] in rex_list    ################## 混淆dart端资源部分 ############################SPECIAL_STUBS: list = []def modify_android_obfuscation_code(dir_path: str):    CUR_TIME_STAMP = int(time.time())    SPECIAL_STUBS.append('__special_obfus_attri')    SPECIAL_STUBS.append('__special_obfus_func')    # 遍历所有文件，文件逐行扫描， 把__special_stub_attribute改成__special_stub_attribute_时间戳    # 把__special_stub_function改成__special_stub_function_时间戳    _modify_android_obfuscation_code(dir_path, CUR_TIME_STAMP)def _modify_android_obfuscation_code(dir_path: str, time_stamp: str):    for file_path in enumerate_file_in_path(dir_path):        if file_path.endswith('.java') or file_path.endswith('.kt'):            _modify_android_obfuscation_in_file(file_path, time_stamp)def _modify_android_obfuscation_in_file(file_path: str, time_stamp: str):    with open(file_path, 'r+') as f:        has_edited: bool = False        lines = f.readlines()        attribute_name = f'{SPECIAL_STUBS[0]}'        function_name = f'{SPECIAL_STUBS[1]}'        new_attribute = f'{attribute_name}_{time_stamp}'        new_function = f'{function_name}_{time_stamp}'        for i, line in enumerate(lines):            if attribute_name in line:                new_line: str = line.replace(attribute_name, new_attribute)                lines[i] = new_line                has_edited = True            elif function_name in line:                new_line: str = line.replace(function_name, new_function)                lines[i] = new_line                has_edited = True        if has_edited:            f.seek(0)            f.truncate()            f.writelines(lines)######################### main #################################if __name__ == '__main__':    ## 本混淆脚本的功能包括：    ## 修改dart端、android资源名，修改android端垃圾代码，产生android端proguard所用混淆字典。    parser = argparse.ArgumentParser()    parser.add_argument('path', type=str)    args = parser.parse_args()    cur_path = os.path.abspath(args.path)    android_path = os.path.join(cur_path, 'android/app/src/main')    build_dir_path = os.path.join(cur_path, 'build')    print('## 混淆脚本jt_obfuscation.py开始执行 ...')    # 删除build/目录    print('删除build/目录')    if os.path.exists(build_dir_path):        shutil.rmtree(build_dir_path)    # 产生android端proguard所用混淆字典    print('产生android端proguard所用混淆字典')    # gen_proguard_dict(cur_path)    # 修改dart端资源名（修改assets下资源名为随机名）    print('修改dart端资源名 - assets下资源名改成随机名')    pubspec_file_path: str = os.path.join(cur_path, 'pubspec.yaml')    pubspec_data = get_yaml_data(pubspec_file_path)    new_pubspec_data = gen_new_resource_name(pubspec_data)    save_new_pubspec(new_pubspec_data, pubspec_file_path)    replace_resource_in_dart(cur_path)    # 修改android端资源名    print('修改android端资源名 - 修改图片、string、color、dimen等资源名为随机名')    replace_resource_in_android(android_path)    # 修改android端垃圾代码    print('修改android端垃圾代码')    modify_android_obfuscation_code(android_path)    print('## 混淆脚本执行结束!')